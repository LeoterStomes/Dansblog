---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';
import MobileDrawer from '../components/MobileDrawer.astro';
import TocSidebar from '../components/TocSidebar.astro';
import TocDrawer from '../components/TocDrawer.astro';

/* Blog post layout coordinates desktop TOC, mobile drawer TOC, and route-transition-safe scripts. */
type Props = CollectionEntry<'blog'>['data'] & {
	profileImage?: string;
	headings?: { depth: number; slug: string; text: string }[];
	rawBody?: string;
	languageSwitch?: {
		href: string;
		label: string;
	};
};

const {
	title,
	description,
	pubDate,
	updatedDate,
	heroImage,
	profileImage,
	tags = [],
	headings = [],
	rawBody = '',
	languageSwitch,
} = Astro.props;

const BASE = import.meta.env.BASE_URL;
const withBase = (path: string) => {
	// Keep public asset references resilient across root and subpath deployments.
	if (!path) return path;
	if (path.startsWith('http://') || path.startsWith('https://')) return path;
	if (path.startsWith(BASE)) return path;
	return `${BASE}${path.replace(/^\/+/, '')}`;
};

const tocItems = headings.filter((h) => h.depth === 2 || h.depth === 3 || h.depth === 4);
const hasToc = tocItems.length > 0;
// Reading time is character-based to stay language-neutral for mixed CN/EN content.
const chars = rawBody.replace(/\s+/g, '').length;
const minutes = Math.max(1, Math.ceil(chars / 950));
const charsLabel = chars.toLocaleString('en-US');
---

<html lang="en">
	<head>
		<BaseHead title={title} description={description} />
	</head>
	<body>
		<Header showTocButton={hasToc} />
		<MobileDrawer />

		<!-- Page fade is CSS-driven so route changes remain smooth even when shared-element transitions are bypassed. -->
		<main class="blog-post-page page-fade-in min-h-screen min-w-0 w-full py-10 md:py-14" transition:animate="fade">
			<div class="mx-auto max-w-7xl min-w-0 px-4 sm:px-6 lg:px-8">
				<div class="mt-10 min-w-0 md:grid md:grid-cols-[240px_minmax(0,1fr)] md:items-start md:gap-10 lg:grid-cols-[280px_minmax(0,820px)_minmax(0,1fr)] lg:gap-x-10">
					<aside class="hidden md:block md:self-stretch">
						<div class="relative sticky top-24" data-toc-fade-wrap>
							<div class="toc-scroll max-h-[calc(100dvh-7.5rem)] overflow-auto pr-2" data-toc-scroll="sidebar">
								{
									hasToc ? (
										<TocSidebar headings={tocItems} />
									) : (
										// Placeholder keeps first paint geometry stable when a post has no headings.
										<div
											class="min-h-[220px] rounded-2xl border border-transparent bg-transparent"
											aria-hidden="true"
										></div>
									)
								}
							</div>
							<div
								data-toc-fade="top"
								class="toc-fade toc-fade-top pointer-events-none absolute inset-x-0 top-0 h-8 opacity-0"
							></div>
							<div
								data-toc-fade="bottom"
								class="toc-fade toc-fade-bottom pointer-events-none absolute inset-x-0 bottom-0 h-8 opacity-0"
							></div>
						</div>
					</aside>

					<main class="min-w-0 lg:col-start-2">
						<header class="mb-10 min-w-0 border-b border-zinc-200 pb-6 dark:border-zinc-700">
							<p class="m-0 text-sm text-zinc-500 dark:text-zinc-400">
								<FormattedDate date={pubDate} />
								<span class="mx-1.5">&middot;</span>
								<span>{charsLabel} chars</span>
								<span class="mx-1.5">&middot;</span>
								<span>{minutes} min</span>
								{updatedDate && (
									<span class="ml-3 inline-block italic">
										Updated <FormattedDate date={updatedDate} />
									</span>
								)}
							</p>

							<div class="mt-3 flex min-w-0 items-start justify-between gap-4">
								<h1
									class="min-w-0 flex-1 font-sans text-3xl font-semibold leading-tight tracking-tight text-zinc-900 [overflow-wrap:anywhere] dark:text-zinc-100 md:text-4xl"
									transition:animate="fade"
								>
									{title}
								</h1>

								{profileImage && (
									<img
										src={withBase(profileImage)}
										alt={`${title} profile`}
										class="h-14 w-14 shrink-0 rounded-full border border-zinc-200 object-cover dark:border-zinc-700 md:h-16 md:w-16"
										loading="lazy"
									/>
								)}
							</div>

							<p class="mt-3 font-serif text-zinc-600 dark:text-zinc-300">{description}</p>

							{languageSwitch && (
								<div class="mt-4">
									<a
										href={languageSwitch.href}
										class="inline-flex items-center rounded-lg border border-zinc-200 px-3 py-1.5 text-sm font-medium text-zinc-700 no-underline transition-colors hover:border-zinc-300 hover:text-zinc-900 dark:border-zinc-700 dark:text-zinc-300 dark:hover:border-zinc-500 dark:hover:text-zinc-100"
										transition:name="lang-switch"
										transition:animate="none"
										data-astro-reload
									>
										{languageSwitch.label}
									</a>
								</div>
							)}

							{tags.length > 0 && (
								<div class="mt-4 flex flex-wrap gap-2">
									{tags.map((tag) => (
										<a
											href={`${BASE}tags/${encodeURIComponent(tag)}/`}
											class="rounded-lg border border-zinc-200 px-2.5 py-1 text-xs font-medium text-zinc-600 no-underline transition-colors hover:border-zinc-300 hover:text-zinc-900 dark:border-zinc-700 dark:text-zinc-300 dark:hover:border-zinc-500 dark:hover:text-zinc-100"
										>
											#{tag}
										</a>
									))}
								</div>
							)}
						</header>

						<article class="section-enter min-w-0 w-full max-w-none">
							{
								heroImage &&
									(typeof heroImage === 'string' ? (
										<div class="mb-8 aspect-[16/9] overflow-hidden rounded-2xl border border-zinc-200 bg-white dark:border-zinc-700 dark:bg-zinc-900">
											<img src={withBase(heroImage)} alt={title} class="h-full w-full object-cover" loading="lazy" />
										</div>
									) : (
										<div class="mb-8 overflow-hidden rounded-2xl border border-zinc-200 bg-white dark:border-zinc-700 dark:bg-zinc-900">
											<Image width={1200} height={620} src={heroImage} alt="" class="h-auto w-full" />
										</div>
									))
							}

							<div class="markdown-prose min-w-0">
								<slot />
							</div>
						</article>

						<TocDrawer headings={tocItems} />
					</main>

					<div class="hidden lg:block" aria-hidden="true"></div>
				</div>
			</div>
		</main>

		<Footer />

		<div
			id="img-lightbox"
			class="fixed inset-0 z-[999] hidden items-center justify-center overflow-auto bg-black/70 p-4 md:p-8 dark:bg-black/80"
			aria-hidden="true"
		>
			<button
				id="img-lightbox-close"
				type="button"
				class="fixed right-4 top-4 inline-flex h-10 w-10 items-center justify-center rounded-full border border-white/25 bg-black/35 text-white transition-colors hover:bg-black/55"
				aria-label="Close image preview"
				data-lightbox-close
			>
				<svg viewBox="0 0 24 24" class="h-5 w-5 fill-current" aria-hidden="true">
					<path d="M6.7 5.3a1 1 0 0 0-1.4 1.4L10.6 12l-5.3 5.3a1 1 0 1 0 1.4 1.4l5.3-5.3 5.3 5.3a1 1 0 1 0 1.4-1.4L13.4 12l5.3-5.3a1 1 0 0 0-1.4-1.4L12 10.6 6.7 5.3Z" />
				</svg>
			</button>
			<img
				id="img-lightbox-target"
				src=""
				alt=""
				class="mx-auto block h-auto max-h-[92dvh] max-w-[92vw] rounded-xl object-contain shadow-lg"
			/>
		</div>

		<style is:global>
			.markdown-prose :is(h2, h3, h4) {
				scroll-margin-top: 7rem;
			}
		</style>

		<script is:inline>
			const scrollToTopIfNoHash = () => {
				// Manual restoration prevents stale scroll positions when View Transitions swap pages.
				try {
					if ('scrollRestoration' in history) history.scrollRestoration = 'manual';
				} catch {}
				if (!window.location.hash) {
					requestAnimationFrame(() => requestAnimationFrame(() => window.scrollTo(0, 0)));
				}
			};

			const initTocActiveState = () => {
				// Clean and re-bind because Astro swaps DOM without a full page refresh.
				if (typeof window.__tocCleanup === 'function') {
					window.__tocCleanup();
					window.__tocCleanup = null;
				}

				const links = Array.from(document.querySelectorAll('[data-toc-link]'));
				const headings = Array.from(
					document.querySelectorAll('.markdown-prose h2[id], .markdown-prose h3[id], .markdown-prose h4[id]')
				);

				if (links.length === 0 || headings.length === 0) return;

				const ACTIVE_CLASSES = [
					'bg-zinc-100/55',
					'text-zinc-900',
					'border-zinc-400/90',
					'dark:bg-zinc-800/55',
					'dark:text-zinc-100',
					'dark:border-zinc-500/90',
				];

				const linkMap = new Map();
				for (const link of links) {
					const id = link.dataset.tocLink || '';
					if (!id) continue;
					const group = linkMap.get(id) || [];
					group.push(link);
					linkMap.set(id, group);
				}

				const clearActive = () => {
					for (const link of links) {
						link.classList.remove(...ACTIVE_CLASSES);
						link.removeAttribute('aria-current');
					}
				};

				const ensureVisibleInToc = (link) => {
					const container = link.closest('[data-toc-scroll]');
					if (!container) return;
					const cRect = container.getBoundingClientRect();
					const eRect = link.getBoundingClientRect();
					if (eRect.top < cRect.top || eRect.bottom > cRect.bottom) {
						link.scrollIntoView({ block: 'nearest' });
					}
				};

				const setActive = (id) => {
					clearActive();
					if (!id) return;
					const group = linkMap.get(id) || [];
					for (const link of group) {
						link.classList.add(...ACTIVE_CLASSES);
						link.setAttribute('aria-current', 'true');
						// Scroll only inside the TOC container to avoid jolting the main article viewport.
						ensureVisibleInToc(link);
					}
				};

				const getActiveIdByScroll = () => {
					let current = headings[0]?.id || '';
					for (const heading of headings) {
						if (heading.getBoundingClientRect().top <= 140) current = heading.id;
					}
					return current;
				};

				let rafId = 0;
				const scheduleApply = () => {
					if (rafId) cancelAnimationFrame(rafId);
					rafId = requestAnimationFrame(() => {
						setActive(getActiveIdByScroll());
					});
				};

				const onHashChange = () => {
					const id = decodeURIComponent(window.location.hash.replace(/^#/, ''));
					if (id && linkMap.has(id)) {
						setActive(id);
					} else {
						scheduleApply();
					}
				};

				window.addEventListener('scroll', scheduleApply, { passive: true });
				window.addEventListener('resize', scheduleApply);
				window.addEventListener('hashchange', onHashChange);

				const hashId = decodeURIComponent(window.location.hash.replace(/^#/, ''));
				if (hashId && linkMap.has(hashId)) {
					setActive(hashId);
				} else {
					scheduleApply();
				}

				window.__tocCleanup = () => {
					if (rafId) cancelAnimationFrame(rafId);
					window.removeEventListener('scroll', scheduleApply);
					window.removeEventListener('resize', scheduleApply);
					window.removeEventListener('hashchange', onHashChange);
				};
			};

			const initTocScrollFades = () => {
				// Fades are computed from scroll state to hint overflow without extra permanent chrome.
				if (typeof window.__tocFadeCleanup === 'function') {
					window.__tocFadeCleanup();
					window.__tocFadeCleanup = null;
				}

				const wraps = Array.from(document.querySelectorAll('[data-toc-fade-wrap]'));
				if (wraps.length === 0) return;

				const cleanups = [];
				const updateFns = [];
				const EPS = 1;

				for (const wrap of wraps) {
					const container = wrap.querySelector('[data-toc-scroll]');
					const topFade = wrap.querySelector('[data-toc-fade="top"]');
					const bottomFade = wrap.querySelector('[data-toc-fade="bottom"]');
					if (!container || !topFade || !bottomFade) continue;
					let rafId = 0;

					const applyFadeState = () => {
						rafId = 0;
						const canScroll = container.scrollHeight - container.clientHeight > EPS;
						if (!canScroll) {
							topFade.classList.add('opacity-0');
							topFade.classList.remove('opacity-100');
							bottomFade.classList.add('opacity-0');
							bottomFade.classList.remove('opacity-100');
							return;
						}

						const showTop = container.scrollTop > EPS;
						const showBottom = container.scrollTop + container.clientHeight < container.scrollHeight - EPS;

						topFade.classList.toggle('opacity-100', showTop);
						topFade.classList.toggle('opacity-0', !showTop);
						bottomFade.classList.toggle('opacity-100', showBottom);
						bottomFade.classList.toggle('opacity-0', !showBottom);
					};

					const scheduleFadeUpdate = () => {
						if (rafId) return;
						rafId = requestAnimationFrame(applyFadeState);
					};

					container.addEventListener('scroll', scheduleFadeUpdate, { passive: true });
					cleanups.push(() => {
						container.removeEventListener('scroll', scheduleFadeUpdate);
						if (rafId) cancelAnimationFrame(rafId);
					});
					updateFns.push(applyFadeState);
					applyFadeState();
				}

				const refreshAll = () => {
					for (const update of updateFns) update();
				};

				window.addEventListener('resize', refreshAll);
				window.addEventListener('toc:refresh', refreshAll);
				cleanups.push(() => window.removeEventListener('resize', refreshAll));
				cleanups.push(() => window.removeEventListener('toc:refresh', refreshAll));

				window.__tocFadeCleanup = () => {
					for (const fn of cleanups) fn();
				};
			};

			const initImageLightbox = () => {
				// Bind once globally; route swaps re-render nodes but should not duplicate listeners.
				if (window.__imgLightboxBound) return;
				window.__imgLightboxBound = true;

				let lockedScrollY = 0;
				const bodyStyleBeforeLock = {
					position: '',
					top: '',
					left: '',
					right: '',
					width: '',
					overflow: '',
				};
				let isBodyLocked = false;

				const getLightboxElements = () => {
					const overlay = document.getElementById('img-lightbox');
					const target = document.getElementById('img-lightbox-target');
					return { overlay, target };
				};

				const closeLightbox = () => {
					const { overlay, target } = getLightboxElements();
					if (!overlay || !target || overlay.classList.contains('hidden')) return;

					overlay.classList.add('hidden');
					overlay.classList.remove('flex');
					overlay.setAttribute('aria-hidden', 'true');
					target.setAttribute('src', '');
					target.setAttribute('alt', '');

					if (isBodyLocked) {
						document.body.style.position = bodyStyleBeforeLock.position;
						document.body.style.top = bodyStyleBeforeLock.top;
						document.body.style.left = bodyStyleBeforeLock.left;
						document.body.style.right = bodyStyleBeforeLock.right;
						document.body.style.width = bodyStyleBeforeLock.width;
						document.body.style.overflow = bodyStyleBeforeLock.overflow;
						window.scrollTo(0, lockedScrollY);
						isBodyLocked = false;
					}
				};

				const openLightbox = (src, altText) => {
					const { overlay, target } = getLightboxElements();
					if (!overlay || !target || !src) return;

					if (!isBodyLocked) {
						lockedScrollY = window.scrollY;
						bodyStyleBeforeLock.position = document.body.style.position;
						bodyStyleBeforeLock.top = document.body.style.top;
						bodyStyleBeforeLock.left = document.body.style.left;
						bodyStyleBeforeLock.right = document.body.style.right;
						bodyStyleBeforeLock.width = document.body.style.width;
						bodyStyleBeforeLock.overflow = document.body.style.overflow;
						document.body.style.position = 'fixed';
						document.body.style.top = `-${lockedScrollY}px`;
						document.body.style.left = '0';
						document.body.style.right = '0';
						document.body.style.width = '100%';
						document.body.style.overflow = 'hidden';
						isBodyLocked = true;
					}

					target.setAttribute('src', src);
					target.setAttribute('alt', altText || '');
					overlay.classList.remove('hidden');
					overlay.classList.add('flex');
					overlay.setAttribute('aria-hidden', 'false');
				};

				document.addEventListener('click', (event) => {
					const rawTarget = event.target;
					if (!(rawTarget instanceof Element)) return;

					const { overlay } = getLightboxElements();
					if (overlay && !overlay.classList.contains('hidden')) {
						if (rawTarget === overlay || rawTarget.closest('[data-lightbox-close]')) {
							event.preventDefault();
							closeLightbox();
							return;
						}
					}

					if (!(rawTarget instanceof HTMLImageElement)) return;
					if (!rawTarget.closest('.markdown-prose')) return;

					const anchor = rawTarget.closest('a');
					if (anchor) event.preventDefault();

					const imgSrc = rawTarget.currentSrc || rawTarget.src;
					if (!imgSrc) return;
					openLightbox(imgSrc, rawTarget.alt || '');
				});

				document.addEventListener('keydown', (event) => {
					if (event.key !== 'Escape') return;
					closeLightbox();
				});
			};

			const resetPageScrollLocks = () => {
				// Defensive unlock protects against interrupted lightbox flows during route changes.
				document.documentElement.classList.remove('overflow-hidden');
				const topOffset = Number.parseInt(document.body.style.top || '0', 10);
				const shouldRestoreBody = document.body.style.position === 'fixed';
				if (!shouldRestoreBody) return;
				document.body.style.position = '';
				document.body.style.top = '';
				document.body.style.left = '';
				document.body.style.right = '';
				document.body.style.width = '';
				document.body.style.overflow = '';
				if (!Number.isNaN(topOffset) && topOffset < 0) {
					window.scrollTo(0, Math.abs(topOffset));
				}
			};

			const onPostPageLoad = () => {
				// Centralize post-page bootstrapping so astro:page-load and astro:after-swap stay identical.
				resetPageScrollLocks();
				scrollToTopIfNoHash();
				initTocActiveState();
				initTocScrollFades();
				initImageLightbox();
			};

			onPostPageLoad();
			if (!window.__blogPostEventsBound) {
				document.addEventListener('astro:page-load', onPostPageLoad);
				document.addEventListener('astro:after-swap', onPostPageLoad);
				window.__blogPostEventsBound = true;
			}
		</script>
	</body>
</html>


